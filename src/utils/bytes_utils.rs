use rand::TryRngCore;

/// Utility functions for creating fixed-size byte arrays from variable-length slices.
/// These are useful when you need to ensure fixed-size inputs (e.g., for cryptographic keys or payloads).

/// Converts a byte slice to a fixed-size 16-byte array by padding with zeros or truncating.
///
/// Description:
/// Takes a byte slice of any length and returns a 16-byte array.
/// If the input is shorter than 16 bytes, the remainder is zero-padded.
/// If the input is longer than 16 bytes, it is truncated.
///
/// Input:
/// - Any byte slice (`&[u8]`) of arbitrary length.
///
/// Output:
/// - A 16-byte fixed-size array (`[u8; 16]`).
pub fn to_fixed_16(input: &[u8]) -> [u8; 16] {
    let mut fixed = [0u8; 16];
    let len = input.len().min(16);
    fixed[..len].copy_from_slice(&input[..len]);
    fixed
}

/// Converts a byte slice to a fixed-size 32-byte array by padding with zeros or truncating.
///
/// Description:
/// Takes a byte slice of any length and returns a 32-byte array.
/// If the input is shorter than 32 bytes, the remainder is zero-padded.
/// If the input is longer than 32 bytes, it is truncated.
///
/// Input:
/// - Any byte slice (`&[u8]`) of arbitrary length.
///
/// Output:
/// - A 32-byte fixed-size array (`[u8; 32]`).
pub fn to_fixed_32(input: &[u8]) -> [u8; 32] {
    let mut fixed = [0u8; 32];
    let len = input.len().min(32);
    fixed[..len].copy_from_slice(&input[..len]);
    fixed
}

/// Returns a 16-byte array of all zeros.
///
/// Description:
/// Returns a fixed-size 16-byte array filled with zeros.
///
/// Input:
/// - None.
///
/// Output:
/// - A 16-byte fixed-size array (`[u8; 16]`) containing all zeros.
pub fn zero_16() -> [u8; 16] {
    [0u8; 16]
}

/// Returns a 32-byte array of all zeros.
///
/// Description:
/// Returns a fixed-size 32-byte array filled with zeros.
///
/// Input:
/// - None.
///
/// Output:
/// - A 32-byte fixed-size array (`[u8; 32]`) containing all zeros.
pub fn zero_32() -> [u8; 32] {
    [0u8; 32]
}

/// Generates a cryptographically secure random secret key.
///
/// Description:
/// Creates a vector of 32 bytes filled with cryptographically secure random bytes
/// suitable for use as a secret key in cryptographic algorithms.
///
/// Input:
/// - None.
///
/// Output:
/// - A `Vec<u8>` of length 32 containing random bytes generated by the OS RNG.
///
/// Panics:
/// - If the OS random number generator fails to produce random data.
pub fn generate_secret_key() -> Vec<u8> {
    let mut key = vec![0u8; 32];
    let mut rng = rand::rngs::OsRng;
    rng.try_fill_bytes(&mut key).expect("OS RNG failed");
    key
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_fixed_16_padding() {
        let input = b"short";
        let result = to_fixed_16(input);
        assert_eq!(&result[..5], input);
        assert_eq!(result[5..], [0u8; 11]);
    }

    #[test]
    fn test_to_fixed_16_truncating() {
        let input = b"this_is_more_than_16_bytes";
        let result = to_fixed_16(input);
        assert_eq!(&result, &input[..16]);
    }

    #[test]
    fn test_to_fixed_32_padding() {
        let input = b"tiny";
        let result = to_fixed_32(input);
        assert_eq!(&result[..4], input);
        assert_eq!(result[4..], [0u8; 28]);
    }

    #[test]
    fn test_zero_arrays() {
        assert_eq!(zero_16(), [0u8; 16]);
        assert_eq!(zero_32(), [0u8; 32]);
    }

    #[test]
    fn test_generate_secret_key_length() {
        let key = generate_secret_key();
        assert_eq!(key.len(), 32);
    }

    #[test]
    fn test_generate_secret_key_randomness() {
        let key1 = generate_secret_key();
        let key2 = generate_secret_key();
        assert_ne!(key1, key2);
    }
}
